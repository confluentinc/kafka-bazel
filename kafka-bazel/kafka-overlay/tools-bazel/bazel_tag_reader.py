import os
import re
import json
from pathlib import Path


def check_patterns(patterns: list[re.Pattern], line: str) -> re.Match | None:
    for pattern in patterns:
        match = pattern.search(line)
        if match:
            return match
    return None


def find_tags_in_file(file_path: Path) -> dict | None:
    """
    This will blindly pull every tag that is a string literal. It won't follow imports or variables.
    It will check for a couple known variables like "TestConstants.INTEGRATION_TEST".
    test sharding can be specified with @Tag("bazel:shard_count:2")
    test size can be specified with @Tag("bazel:size:small")
    test cores can be specified with @Tag("bazel:cpu:2").
    In jvm_junit_test_suite, for Integration tests, the default cores is 2, so it doesn't need to be specified.
    Anything else will just be added as a tag to the bazel test target.
    The `bazel:` prefix is stripped off.
    """
    tag_patterns = {
        None: [re.compile(r'^@Tag\("([^"]+)"\)')],
        "integration": [
            re.compile(r"^@Tag\(([\w\.]*TestConstants\.INTEGRATION_TEST)\)"),
            re.compile(r"^@Category\((\{?IntegrationTest\.class\}?)\)"),
        ],
        "property_based": [
            re.compile(r"^@Tag\(([\w\.]*TestConstants\.PROPERTY_BASED_TEST)\)")
        ],
    }
    entry = {}
    lines = file_path.read_text().splitlines()

    for line in lines:
        for tag, patterns in tag_patterns.items():
            match = check_patterns(patterns, line)

            if not match:
                continue

            value = match.group(1) if tag is None else tag
            if not value.startswith("bazel:"):
                entry.setdefault("tags", []).append(value)
                continue

            value = value[len("bazel:") :]
            if value.startswith("shard_count:"):
                entry["shard_count"] = int(value.split(":")[1])
            elif value.startswith("size:"):
                entry["size"] = value.split(":")[1]
            elif value.startswith("jvm_flags:"):
                entry.setdefault("jvm_flags", []).append(value.split(":")[1])
            else:
                entry.setdefault("tags", []).append(value)

    return entry


def scan_directory_for_tags(directory: Path) -> dict:
    results = {}
    for root, _, filenames in os.walk(directory):
        root_path = Path(root).relative_to(directory)
        if root_path.parts and root_path.parts[0] in ["build", "bin", "build_eclipse"]:
            continue

        for filename in filenames:
            if filename.endswith(".java") or filename.endswith(".scala"):
                file_path = Path(root) / filename
                entry = find_tags_in_file(file_path)
                if entry:
                    results[str(file_path.relative_to(directory))] = entry
    return results


def main():
    workspace_path = os.environ.get("BUILD_WORKSPACE_DIRECTORY")
    if not workspace_path:
        raise Exception("Workspace path not found. Are you running via 'bazel run'?")

    directory = workspace_path
    for root, _, filenames in os.walk(directory):
        for filename in filenames:
            if filename == "BUILD.bazel":
                file_path = Path(root) / filename

                if 'load(":generated_test_args.bzl"' not in file_path.read_text():
                    continue

                results = scan_directory_for_tags(file_path.parent)
                output = file_path.parent / "generated_test_args.bzl"
                output_text = f"""
# This file is generated by bazel_tag_reader.py. Edits will be overwritten by
# bazel run //:gen_tags
per_test_args = {json.dumps(results, indent=4, sort_keys=True)}
"""
                output.write_text(output_text.lstrip("\n"))


if __name__ == "__main__":
    main()
